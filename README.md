# üìò JoyFix ‚Äì System ZarzƒÖdzania Serwisem Konsol

## Spis tre≈õci
- [Wprowadzenie](#wprowadzenie)
- [Opis funkcjonalno≈õci](#opis-funkcjonalno≈õci)
- [Architektura systemu](#architektura-systemu)
- [Modele danych](#modele-danych)
- [Konfiguracja bazy danych](#konfiguracja-bazy-danych)
- [Logika biznesowa](#logika-biznesowa)
- [Interfejs u≈ºytkownika (Blazor)](#interfejs-u≈ºytkownika-blazor)
- [Instrukcja obs≈Çugi](#instrukcja-obs≈Çugi)
- [Wymagania systemowe](#wymagania-systemowe)
- [Konfiguracja i uruchomienie](#konfiguracja-i-uruchomienie)

---

## Wprowadzenie
**JoyFix** to aplikacja webowa wspierajƒÖca zarzƒÖdzanie serwisem naprawy konsol i urzƒÖdze≈Ñ elektronicznych. Umo≈ºliwia obs≈Çugƒô klient√≥w, prowadzenie zg≈Çosze≈Ñ serwisowych, przypisywanie technik√≥w i monitorowanie przebiegu napraw.

> Technologia: **ASP.NET Core 8 (Blazor Server)** + **PostgreSQL**

---

## Opis funkcjonalno≈õci
- Dodawanie i edycja klient√≥w
- Rejestrowanie urzƒÖdze≈Ñ
- Tworzenie i zarzƒÖdzanie zg≈Çoszeniami napraw
- Przypisywanie technik√≥w wed≈Çug specjalizacji
- Ewidencjonowanie napraw (koszty, czƒô≈õci, opis pracy)
- Walidacja danych (frontend + backend)
- Interfejs w oparciu o Bootstrap: tabele, formularze, modale

---

## Architektura systemu
- **Frontend**: Blazor Server
- **Backend**: ASP.NET Core (.NET 8)
- **ORM**: Entity Framework Core
- **Baza danych**: PostgreSQL
- **UI**: Bootstrap

---

## Modele danych

**Customer**
```csharp
using System.ComponentModel.DataAnnotations;

namespace JoyFix.Data
{
    public class Customer
    {
        public int Id { get; set; }

        [Required]
        [MaxLength(100)]
        public string Name { get; set; }

        [Required]
        [EmailAddress]
        [MaxLength(100)]
        public string Email { get; set; }

        [Phone]
        [MaxLength(20)]
        public string PhoneNumber { get; set; }

        [MaxLength(200)]
        public string Address { get; set; }

        public ICollection<Device> Devices { get; set; } = new HashSet<Device>();
        public ICollection<RepairRequest> RepairRequests { get; set; } = new HashSet<RepairRequest>();
    }
}
```
**Device**
```csharp
using System.ComponentModel.DataAnnotations;

namespace JoyFix.Data
{
    public class Device
    {
        public int Id { get; set; }

        public int CustomerId { get; set; }

        [Required]
        [MaxLength(50)]
        public string SerialNumber { get; set; }

        [Required]
        [MaxLength(50)]
        public string DeviceType { get; set; }

        [MaxLength(50)]
        public string Model { get; set; }

        public Customer Customer { get; set; }
        public ICollection<RepairRequest> RepairRequests { get; set; } = new HashSet<RepairRequest>();
    }
}
```
**RepairRequest**
```csharp
using System.ComponentModel.DataAnnotations;

namespace JoyFix.Data
{
    public class RepairRequest
    {
        public int Id { get; set; }

        public int CustomerId { get; set; }
        public int DeviceId { get; set; }

        [Required]
        [MaxLength(50)]
        public required string DeviceType { get; set; }

        [Required]
        public required string IssueDescription { get; set; }

        [MaxLength(20)]
        public string Status { get; set; } = "oczekuje";

        public DateTime CreatedAt { get; set; } = DateTime.UtcNow;

        public Repair? Repair { get; set; }

        public Customer Customer { get; set; } = null!;
        public Device Device { get; set; } = null!;
    }
}
```
**Repair**
```csharp
using System.ComponentModel.DataAnnotations;
using System.ComponentModel.DataAnnotations.Schema;

namespace JoyFix.Data
{
    public class Repair
    {
        [Key]
        [ForeignKey("RepairRequest")] 
        public int RepairRequestId { get; set; } 

        public int TechnicianId { get; set; }

        [Required]
        public required string WorkDescription { get; set; }

        public string? PartsUsed { get; set; }

        [Required]
        [Range(0, 100000)]
        public decimal Cost { get; set; }

        public DateTime RepairDate { get; set; } = DateTime.UtcNow;
        public RepairRequest RepairRequest { get; set; } = null!;
        public Technician Technician { get; set; } = null!;
    }
}
```
**Specialization**
```csharp
namespace JoyFix.Data
{
    public class Specialization
    {
        public int Id { get; set; }
        public string Name { get; set; }
        public string Description { get; set; }

        public ICollection<TechnicianSpecialization> Technicians { get; set; } = new HashSet<TechnicianSpecialization>();
    }

    public class TechnicianSpecialization
    {
        public int TechnicianId { get; set; }
        public int SpecializationId { get; set; }
        public DateTime AcquiredDate { get; set; }

        public Technician Technician { get; set; }
        public Specialization Specialization { get; set; }
    }
}
```
**Technician**
```csharp
using System.Collections.Generic;
using System.ComponentModel.DataAnnotations;

namespace JoyFix.Data
{
    public class Technician
    {
        public int Id { get; set; }

        [Required]
        [MaxLength(100)]
        public string Name { get; set; }

        [Required]
        [EmailAddress]
        [MaxLength(100)]
        public string Email { get; set; }

        [Phone]
        [MaxLength(20)]
        public string PhoneNumber { get; set; }

        public ICollection<Repair> Repairs { get; set; } = new HashSet<Repair>();
        public ICollection<TechnicianSpecialization> Specializations { get; set; } = new HashSet<TechnicianSpecialization>();
    }
}
```

---

## Konfiguracja bazy danych
**ContextDB**

ContextDB to g≈Ç√≥wny kontekst bazy danych oparty na Entity Framework Core. Odpowiada za konfiguracjƒô encji, relacji pomiƒôdzy nimi oraz ustawienie ogranicze≈Ñ i indeks√≥w.
```csharp
using Microsoft.EntityFrameworkCore;

namespace JoyFix.Data
{
public class ContextDB : DbContext
{
public ContextDB(DbContextOptions<ContextDB> options) : base(options)
{
}
public DbSet<Customer> Customers { get; set; }
public DbSet<Device> Devices { get; set; }
public DbSet<RepairRequest> RepairRequests { get; set; }
public DbSet<Repair> Repairs { get; set; }
public DbSet<Technician> Technicians { get; set; }
public DbSet<Specialization> Specializations { get; set; }
public DbSet<TechnicianSpecialization> TechnicianSpecializations { get; set; }

        protected override void OnModelCreating(ModelBuilder modelBuilder)
        {
            base.OnModelCreating(modelBuilder);

            modelBuilder.Entity<Customer>()
                .HasMany(c => c.Devices)
                .WithOne(d => d.Customer)
                .HasForeignKey(d => d.CustomerId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<Customer>()
                .HasMany(c => c.RepairRequests)
                .WithOne(rr => rr.Customer)
                .HasForeignKey(rr => rr.CustomerId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<Device>()
                .HasMany(d => d.RepairRequests)
                .WithOne(rr => rr.Device)
                .HasForeignKey(rr => rr.DeviceId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<RepairRequest>()
                .HasOne(rr => rr.Repair)
                .WithOne(r => r.RepairRequest)
                .HasForeignKey<Repair>(r => r.RepairRequestId)
                .OnDelete(DeleteBehavior.Cascade);

            modelBuilder.Entity<Repair>()
                .HasOne(r => r.Technician)
                .WithMany(t => t.Repairs)
                .HasForeignKey(r => r.TechnicianId)
                .OnDelete(DeleteBehavior.Restrict);

            modelBuilder.Entity<TechnicianSpecialization>()
                .HasKey(ts => new { ts.TechnicianId, ts.SpecializationId });

            modelBuilder.Entity<TechnicianSpecialization>()
                .HasOne(ts => ts.Technician)
                .WithMany(t => t.Specializations)
                .HasForeignKey(ts => ts.TechnicianId);

            modelBuilder.Entity<TechnicianSpecialization>()
                .HasOne(ts => ts.Specialization)
                .WithMany(s => s.Technicians)
                .HasForeignKey(ts => ts.SpecializationId);

            modelBuilder.Entity<Customer>()
                .HasIndex(c => c.Email)
                .IsUnique();

            modelBuilder.Entity<Device>()
                .HasIndex(d => d.SerialNumber)
                .IsUnique();

            modelBuilder.Entity<RepairRequest>()
                .HasIndex(rr => rr.Status);

            modelBuilder.Entity<Technician>()
                .HasIndex(t => t.Email)
                .IsUnique();

        }
    }
}
```
**Customer** posiada wiele Devices i RepairRequests (cascade delete).

**Device** powiƒÖzany jest z wieloma RepairRequests.

**RepairRequest** ma dok≈Çadnie jeden Repair (relacja jeden-do-jednego).

**Repair** przypisany jest do jednego Technician (bez kasowania kaskadowego).

**Technician** mo≈ºe mieƒá wiele Specializations poprzez tabelƒô po≈õredniczƒÖcƒÖ TechnicianSpecialization (relacja wiele-do-wielu).

Dodano unikalne indeksy dla p√≥l: Email (Customer i Technician) oraz SerialNumber (Device).

Indeks utworzono r√≥wnie≈º dla pola Status w RepairRequest.

**Warto≈õci domy≈õlne:** Status zg≈Çoszenia naprawy ustawiany domy≈õlnie na oczekuje.

Pola wymagane i ograniczenia walidacyjne definiowane przy pomocy adnotacji (DataAnnotations) w modelach.

**Seedy danych**

System zawiera zdefiniowane seedy startowe, kt√≥re pozwalajƒÖ szybko zainicjalizowaƒá testowe ≈õrodowisko napraw konsolowych.

**Klasa:** ```DatabaseSeeder```

Centralna klasa agregujƒÖca wywo≈Çanie wszystkich seeder√≥w:
```csharp
using JoyFix.Data;
using JoyFix.Data.Seeders;

namespace JoyFix.Seeders
{
public static class DatabaseSeeder
{
public static void Seed(ContextDB context)
{
CustomerSeeder.Seed(context);
DeviceSeeder.Seed(context);
TechnicianSeeder.Seed(context);
RepairRequestSeeder.Seed(context);
RepairSeeder.Seed(context);
}
}
}
```
**Zakres seedowanych danych:**

**CustomerSeeder** ‚Äì Dodaje 3 przyk≈Çadowych klient√≥w z danymi kontaktowymi.

**DeviceSeeder** ‚Äì Tworzy 6 urzƒÖdze≈Ñ przypisanych do klient√≥w (r√≥≈ºne typy konsol Nintendo, PlayStation, Xbox).

**TechnicianSeeder** ‚Äì Trzech technik√≥w z przypisanymi specjalizacjami odpowiadajƒÖcymi markom i typom usterek.

**RepairRequestSeeder** ‚Äì Generuje zg≈Çoszenia serwisowe w zale≈ºno≈õci od typu urzƒÖdzenia i przypisuje je do odpowiednich klient√≥w.

**RepairSeeder** ‚Äì Tworzy rekordy napraw powiƒÖzane z istniejƒÖcymi zg≈Çoszeniami oraz przypisuje je technikom na podstawie dopasowania specjalizacji.

---

## Logika Biznesowa

**Og√≥lna struktura**

- Ka≈ºda klasa Service korzysta z DynamicDbContextFactory, co pozwala dynamicznie zarzƒÖdzaƒá wieloma kontekstami baz danych ‚Äî dobry wyb√≥r przy np. wielu tenantach.

- Ka≈ºdy Service implementuje metody CRUD, walidacje oraz relacje encji przez Include() ‚Äî co poprawia czytelno≈õƒá i obs≈Çugƒô z≈Ço≈ºonych struktur danych.

**CustomerService**

- Pobiera klient√≥w wraz z ich urzƒÖdzeniami i zg≈Çoszeniami (Devices, RepairRequests).

- Waliduje unikalno≈õƒá e-maila i numeru telefonu (tylko cyfry) przy tworzeniu/edycji.

-  tu bardziej zaawansowanej walidacji numeru telefonu (np. d≈Çugo≈õƒá, format miƒôdzynarodowy itp.) ‚Äî mo≈ºesz to rozbudowaƒá w przysz≈Ço≈õci.

**DeviceService**

- Sprawdza unikalno≈õƒá numeru seryjnego.

- Chroni przed usuniƒôciem urzƒÖdzenia, kt√≥re ma powiƒÖzane zg≈Çoszenia napraw.

- Dzia≈Ça dobrze w kontek≈õcie powiƒÖza≈Ñ Device ‚Üî Customer i RepairRequest.

**RepairRequestService**

- Obs≈Çuguje zg≈Çoszenia napraw, przypisane do Device, Customer, opcjonalnie Repair.

- Walidacja istnienia urzƒÖdzenia i klienta.

- Blokuje usuniƒôcie zg≈Çoszenia, je≈õli ma ju≈º przypisanƒÖ naprawƒô (Repair).

- U≈ºywa status√≥w: "oczekuje", "w trakcie" ‚Äî mo≈ºna dodaƒá enum dla lepszej kontroli stanu.
 
**RepairService**

- ZarzƒÖdza naprawami i automatycznie aktualizuje status RepairRequest przy tworzeniu/edycji/usuniƒôciu naprawy.

- Dobry mechanizm aktualizacji statusu: "oczekuje" ‚Üî "w trakcie".

- Waliduje istnienie technika i zg≈Çoszenia przed dodaniem naprawy.

- Unika duplikowania naprawy dla jednego zg≈Çoszenia.

**SpecializationService**

- Zabezpiecza przed usuniƒôciem specjalizacji przypisanej do technik√≥w.

- Dobrze zorganizowana logika walidacji unikalno≈õci nazw.

- Obs≈Çuguje relacjƒô Specialization ‚Üî TechnicianSpecialization.

**TechnicianService**

- Obs≈Çuguje technik√≥w, ich specjalizacje oraz przypisane naprawy.

- Chroni przed usuniƒôciem technika, kt√≥ry ma przypisane naprawy.

- Umo≈ºliwia przypisywanie nowych specjalizacji do technik√≥w ‚Äî bardzo dobrze!

- R√≥wnie≈º waliduje unikalno≈õƒá e-maila i format numeru telefonu.

---

## Interfejs u≈ºytkownika (Blazor)

Aplikacja podzielona jest na oddzielne strony z podstronami

**Customers**

```/customers ``` - lista klient√≥w

```/customeradd ``` - dodawanie klient√≥w

```/customeredit ``` - edytowanie klient√≥w

**Devices**

```/devices ``` - lista urzƒÖdze≈Ñ

```/deviceadd ``` - dodawanie urzƒÖdze≈Ñ

```/deviceedit ``` - edytowanie urzƒÖdze≈Ñ

**RepairRequests**

```/repairrequests ``` - lista zg≈Çosze≈Ñ napraw

```/repairrequestadd ``` - dodawanie zg≈Çosze≈Ñ napraw
 
```/repairrequestedit ``` - edytowanie zg≈Çosze≈Ñ napraw

**Repairs**

```/repairs ``` - lista napraw

```/repairadd ``` - dodawanie napraw

```/repairedit ``` - edytowanie napraw

**Specializations**

```/specializations ``` - lista specjalizacji

```/specializationadd ``` - dodawanie specjalizacji

```/specializationedit ``` - edytowanie specjalizacji

**Technicians**

```/technicians ``` - lista technik√≥w

```/technicianadd ``` - dodawanie technik√≥w

```/technicianedit ``` - edytowanie technik√≥w

Ka≈ºda ze stron pozwala na:

- Wy≈õwietlanie list klient√≥w, urzƒÖdze≈Ñ, technik√≥w, napraw itp.

- Filtrowanie listy (wyszukiwanie po nazwie, emailu, typie urzƒÖdzenia itd.).

- Dodawanie, edycjƒô i usuwanie.

- Potwierdzanie usuniƒôcia przez u≈ºytkownika.

--- 

## Instrukcja obs≈Çugi

Ka≈ºdy komponent listowy (np. lista klient√≥w, produkt√≥w, us≈Çug) umo≈ºliwia u≈ºytkownikowi:

- przeglƒÖdanie danych w formie tabeli,

- filtrowanie i wyszukiwanie rekord√≥w po wybranych kryteriach,

- dodawanie nowych rekord√≥w,

- edycjƒô istniejƒÖcych,

 - usuwanie niepotrzebnych danych.

**Filtrowanie**

Na g√≥rze strony znajduje siƒô formularz filtrowania, kt√≥ry umo≈ºliwia przeszukiwanie danych po r√≥≈ºnych polach (np. imiƒô, email, telefon, adres). U≈ºytkownik mo≈ºe:

- wpisaƒá dane w dowolne pole (np. fragment imienia lub numer telefonu),

- kliknƒÖƒá przycisk ‚ÄûSearch‚Äù, aby zastosowaƒá filtry,

- kliknƒÖƒá ‚ÄûClear all‚Äù, aby wyczy≈õciƒá pola i zobaczyƒá wszystkie rekordy ponownie.

Filtry dzia≈ÇajƒÖ niezale≈ºnie od siebie ‚Äì mo≈ºna u≈ºyƒá jednego lub kilku jednocze≈õnie.

**Tabela danych**

- Lista wszystkich pasujƒÖcych rekord√≥w wy≈õwietlana jest w formie tabeli.

- Kolumny prezentujƒÖ kluczowe dane (np. imiƒô, email, adres).

- Dla ka≈ºdego wiersza dostƒôpne sƒÖ przyciski:

  - Edytuj ‚Äì umo≈ºliwia modyfikacjƒô rekordu,

  - Usu≈Ñ ‚Äì wywo≈Çuje potwierdzenie usuniƒôcia.

**Dodawanie nowego rekordu**

- Przycisk ‚ÄûAdd new‚Äù nad tabelƒÖ przenosi do formularza tworzenia.

- Formularz zawiera wymagane pola i przycisk ‚ÄûZapisz‚Äù.

**Edycja istniejƒÖcego rekordu**

- Klikniƒôcie ‚ÄûEdit‚Äù przy wybranym wierszu otwiera formularz z danymi do edycji.

- Po zapisaniu zmian u≈ºytkownik wraca do listy.

**Usuwanie rekordu**

- Klikniƒôcie ‚ÄûDelete‚Äù wy≈õwietla pytanie o potwierdzenie.

- Po zatwierdzeniu rekord zostaje usuniƒôty z bazy, a lista od≈õwie≈ºona.

**Dodatkowe informacje**

| Element            | Opis                                                                    |
|--------------------|-------------------------------------------------------------------------|
| ≈Åadowanie danych   | Komunikat ‚ÄûLoading...‚Äù pojawia siƒô, gdy dane sƒÖ pobierane.              |
| Obs≈Çuga b≈Çƒôd√≥w     | W przypadku problem√≥w z API ‚Äì pojawia siƒô komunikat o b≈Çƒôdzie.          |
| Brak wynik√≥w       | Je≈õli ≈ºaden rekord nie spe≈Çnia kryteri√≥w filtrowania.                   |
| Potwierdzenia      | Po edycji, dodaniu lub usuniƒôciu u≈ºytkownik widzi zaktualizowanƒÖ listƒô. |

---

## Wymagania systemowe

- .NET 8 lub nowszy

- PostgreSQL (serwer lokalny lub zdalny)

- PrzeglƒÖdarka obs≈ÇugujƒÖca Blazor Server (Chrome, Edge, Firefox)

- System operacyjny: Windows / Linux / macOS

--- 

## Konfiguracja i uruchomienie

Aby uruchomiƒá aplikacjƒô lokalnie, wykonaj poni≈ºsze kroki:

**Wymagania wstƒôpne**

Upewnij siƒô, ≈ºe masz zainstalowane:

- [.NET 8 SDK](https://dotnet.microsoft.com/download)
- [PostgreSQL](https://www.postgresql.org/download/)
- IDE, np. [Visual Studio 2022+](https://visualstudio.microsoft.com/pl/) lub [Rider](https://www.jetbrains.com/rider/)
- Narzƒôdzia Entity Framework (je≈õli chcesz rƒôcznie wykonywaƒá migracje):
  ```bash
  dotnet tool install --global dotnet-ef
  ```
**Konfiguracja**

1. Ustawienie ≈Ça≈Ñcucha po≈ÇƒÖczenia do bazy danych:
   - W pliku appsettings.json dodaj dane dostƒôpowe do swojej instancji PostgreSQL.


2. Dodanie migracji i aktualizacja bazy danych (opcjonalnie):

   - Je≈õli chcesz rƒôcznie zarzƒÖdzaƒá schematem bazy:
      ```bash
     dotnet ef migrations add InitialCreate
     dotnet ef database update
      ```

3. Automatyczna migracja i seeding:

   - Aplikacja automatycznie wykonuje migracje i wstƒôpne wype≈Çnienie bazy danych przy pierwszym uruchomieniu:


4. Uruchomienie aplikacji

   - Otw√≥rz terminal w katalogu projektu i uruchom aplikacjƒô:
      ```bash
     dotnet run
      ```

   - Aplikacja bƒôdzie dostƒôpna pod adresem:
     https://localhost:5001 (lub innym, zale≈ºnie od konfiguracji)

     
**U≈ºyte rozszerzenia / biblioteki**

- PostgreSQL ‚Äì baza danych

- Entity Framework Core (EF Core) ‚Äì ORM (obs≈Çuga migracji, seeding)

- ASP.NET Core Razor Components (Blazor Server) ‚Äì interfejs u≈ºytkownika

- ProtectedBrowserStorage ‚Äì przechowywanie sesji po stronie klienta

- Bootstrap 5 ‚Äì stylowanie (przy pomocy klas CSS)